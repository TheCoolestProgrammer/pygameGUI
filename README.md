# about

это моя попытка сделать библиотеку для облегчения создание графических интерфейсов при работе с pygame

все необходимые для работы классы хранятся в base_classes5.py

примеры программ можно посмотреть в файлах calc(5).py и vote(5).py

# примечания
в base_classes(5).py все вхождения Stage были ошибочно названы App

#структура программы

ваша прорамма должна представлять из себя экземпляр класса App(или его наследник), бескончено вызывающего метод .mainloop()

в нем должен быть определен список экземпляров класса Stage(или его наследников) - self.stages(по умолчанию он состоит из 1 экземпляра базового класса Stage).
это сделано для того, чтоб в 1 программе можно было менять несколько подпрограмм(например открыть подпрограмму настроек)

информация о нажатиях собирается в методе .events_check() класса App. она сохраняется в следующие переменные
1. self.events - нажатия и отжатия клавиш мыши и клавиатуры
2. self.mouse_pos - позиция мыши относительно левого верхнего угла окна pygame
3. self.mouse_holdown - зажатые клавиши мыши
4. self.keys_holdown - зажатые клавиши клавиатуры
и передается в метод .mainloop() класса Stage

в библиотеке представлен класс Widget - базовая единица подпрограммы, с которой можно взаимодействовать.
от него наследуются все подклассы, например, Window, Button, Text, RatioButton

для взаимодействия с виджетами в них определены переменные self.layers_inspector и self.keys_inspector

self.layers_inspector - экземпляр класса LayerInspector(по умолчанию = None), отвечает за работу со слоями(отрисовка и очередность проверки нажатия клавиш)
__примечание__: если в вашем виджете нет подвиджетов(как, например, есть в Window), то переинициализировать его не надо
в self.events_check(app) прога пробегается по self.layers - списку, в котором лежат все подвиджеты и вызывает у них keys_inspector.check_keys()

self.keys_inspector - экземпляр класса KeysInspector - отвечает за взаимодействие с клавишами. 
в нем объявлена переменная self.checkers - список экземпляров класса Checker или CombinationChecker, 
которые представляют из себя проверчоные механизмы совершения действий. 
если у экземпляра класса Checker self.key сходится с нажатой клавишей, то в экземпляр возврещает True и в KeysInspector вызывается ссылка на исполняемую функцию self.func класса Checker.
если же функция вернула false, то вызывается Checker.alternative_func

__ВАЖНО__: функция, которую должен исполнить KeysInspector должна принимать в качестве аргументов виджет, с которым совершается действие и Stage, активный в данный момент
__примечание__: в Widget.keys_inspector уже в конструкторе добавляются некоторые служебные проверки(например, функция переноса окна призажатии ЛКМ), так что не сотрите их при переинициализации списка  

например, если мы хотим, чтобы при нажатии ЛКМ на кнопку ии цвет менялся на зеленый, при инициализации экземпляра кнопки нужно в экземпляре кнопки в keys_inspector.checkers добавить CombinationChecker, 
реагирующий на пересечение мыши с виджетом(IntersectionChecker), нажатие ЛКМ(TouchChecker(1), ведь 1-ЛКМ, 2-колесико, 3-ПКМ, 4-колесико вниз, 5-колесико вверх)
и чтобы кнопка была доступна для нажатия(тоесть активна(ActiveChecker)) и имеющий ссылку на функцию change_color(widget, stage)

\```python
  button.keys_inspector.checkers.append(baseClasses.CombinationCheckers(
       change_color,
       [baseClasses.IntersectionChecker(),
       baseClasses.TouchChecker(1),
       baseClasses.ActiveChecker()]
     ))
\```

функция cheange_color:
\```python
def change_color(widget,stage):
  widget.color = (0,255,0)
\```

